"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateCommand = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const ts_morph_1 = require("ts-morph");
const TJS = __importStar(require("typescript-json-schema"));
const log_1 = require("../../log");
const config_1 = __importDefault(require("../config"));
const yaml_1 = require("yaml");
const openapi_typescript_1 = __importDefault(require("openapi-typescript"));
const crd_1 = require("../../internal/crd");
const method_map_1 = require("../../utils/method-map");
const log = (0, log_1.makeLogger)("generate", {
    displayFunctionName: false,
});
function findEntryTypeName(sourceFile) {
    const types = sourceFile.getTypeAliases();
    for (let t of types) {
        if (t.isExported() && t.getType().isUnion()) {
            return t.getName();
        }
    }
    throw new Error("No exported union type alias found");
}
const generateCommand = (yargs) => {
    return yargs.command("generate", "Run the generation procedure for the schemas", (args) => args
        .option("crds-only", { alias: "c", type: "boolean", default: false })
        .option("resources-only", { alias: "r", type: "boolean", default: false }), async (args) => {
        if (!args["resources-only"]) {
            await generateCrds();
        }
        if (!args["crds-only"]) {
            await generateResources();
        }
    });
};
exports.generateCommand = generateCommand;
async function generateCrds() {
    var _a, _b, _c, _d, _e, _f, _g;
    let defs = `
type defs = {
`;
    let methodsMap = {};
    let aliasMap = {};
    if (!((_a = config_1.default.crds) === null || _a === void 0 ? void 0 : _a.output))
        return;
    log.info("generating CRDs");
    for (let crd of (_c = (_b = config_1.default.crds) === null || _b === void 0 ? void 0 : _b.list) !== null && _c !== void 0 ? _c : []) {
        const crdPath = path.join(config_1.default.root, crd.path);
        log.info(`opening ${crdPath} as CRD document`);
        const resources = (0, yaml_1.parseAllDocuments)(fs.readFileSync(crdPath, "utf8")).map((x) => x.toJSON());
        for (let resource of resources) {
            if (!(0, crd_1.isCrd)(resource))
                continue;
            if (!resource.spec.group.includes(crd.groupPrefix))
                continue;
            const groupName = resource.spec.group.replace("." + crd.groupPrefix, "").replace(crd.groupPrefix, "");
            const versions = resource.spec.versions.filter((x) => x.served);
            for (let version of versions) {
                if (!((_d = version.schema) === null || _d === void 0 ? void 0 : _d.openAPIV3Schema))
                    continue;
                const fqdn = `${crd.name}` + (groupName != "" ? `.${groupName}.` : ".") + `${version.name}.${resource.spec.names.kind}`;
                log.debug(`generating crd for ${fqdn}`);
                aliasMap[fqdn] = `${resource.spec.group}/${version.name}#${resource.spec.names.kind}`;
                const rawText = await (0, openapi_typescript_1.default)({
                    openapi: "3",
                    components: {
                        schemas: {
                            _schema: version.schema.openAPIV3Schema,
                        },
                    },
                }, {
                    additionalProperties: true,
                });
                defs +=
                    "    " +
                        rawText
                            .replace("export interface operations {}", "")
                            .replace("export interface external {}", "")
                            .replace("export interface paths {}", "")
                            .replace(`/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */`, "")
                            .replace("export interface components {", "")
                            .replace("schemas: {", "")
                            .replace("_schema: {", `"${fqdn}": {`)
                            .replace("  };\n}", "")
                            .trim() +
                        "\n";
                const methodComponents = fqdn.split(".").filter((x) => x.trim().length > 0);
                const methodName = methodComponents[methodComponents.length - 1];
                let parts = methodsMap;
                for (let component of methodComponents) {
                    if (!parts[component]) {
                        if (component == methodName) {
                            parts[component] = fqdn;
                        }
                        else {
                            parts[component] = {};
                        }
                    }
                    if (typeof parts[component] == "object") {
                        parts = parts[component];
                    }
                }
            }
        }
    }
    defs += `};`;
    if (!fs.existsSync(config_1.default.crds.output)) {
        log.debug("creating directory", path.dirname(path.join(config_1.default.root, (_e = config_1.default.crds) === null || _e === void 0 ? void 0 : _e.output, "index.ts")));
        fs.mkdirSync(config_1.default.crds.output, { recursive: true });
    }
    log.info("writing schema to", path.join(config_1.default.root, (_f = config_1.default.crds) === null || _f === void 0 ? void 0 : _f.output, "index.ts"));
    fs.writeFileSync(path.join(config_1.default.root, (_g = config_1.default.crds) === null || _g === void 0 ? void 0 : _g.output, "index.ts"), `/**
* This file was generated by kubernate.
* Do not edit this file manually. Any changes will be overwritten.
*/

import {crdApiCallMethod, CRDApiCallMethod} from "kubernate/internal/api";

${defs}

export type CRD<T extends keyof defs> = defs[T];

export type DefinitionsMap = {
${(0, method_map_1.renderMethodMap)("api", method_map_1.CRDApiTypeFormatter, methodsMap, undefined, 1)}
};
    
const definitions: DefinitionsMap = {
${(0, method_map_1.renderMethodMap)("api", method_map_1.CRDApiCallFormatter, methodsMap, aliasMap, 1)}
};

const crds = definitions.api;
export default crds;
`.trim());
}
async function generateResources() {
    var _a, _b, _c;
    if (!config_1.default.resources) {
        log.error("No resources configured");
        process.exit(1);
    }
    const sourcePath = path.join(config_1.default.root, config_1.default.resources.entry);
    log.info("opening", sourcePath, "as entry file");
    const project = new ts_morph_1.Project({});
    const mainSource = project.addSourceFileAtPath(sourcePath);
    const dependencies = project.resolveSourceFileDependencies();
    const dependenciesMap = {};
    const typeAliasName = (_b = (_a = config_1.default.resources) === null || _a === void 0 ? void 0 : _a.entryTypeName) !== null && _b !== void 0 ? _b : findEntryTypeName(mainSource);
    log.info("using exported type", typeAliasName);
    const mainType = mainSource.getTypeAliasOrThrow(typeAliasName).getType();
    const declaredServices = (mainType.isUnion()
        ? mainType
            .getUnionTypes()
            .map((x) => {
            var _a, _b, _c;
            return ({
                name: (_b = (_a = x.getSymbol()) === null || _a === void 0 ? void 0 : _a.getName()) !== null && _b !== void 0 ? _b : (_c = x.getAliasSymbol()) === null || _c === void 0 ? void 0 : _c.getName(),
                typeArgs: x
                    .getBaseTypes()
                    .map((x) => x
                    .getAliasTypeArguments()
                    .filter((x) => x.isStringLiteral())
                    .map((x) => x.getLiteralValue()))
                    .reduce((prev, cur) => [...prev, ...cur], []),
            });
        })
            .filter((x) => !!x && x.name !== "__type")
        : [
            {
                name: mainType.getSymbolOrThrow().getName(),
                typeArgs: mainType
                    .getBaseTypes()
                    .map((x) => x
                    .getAliasTypeArguments()
                    .filter((x) => x.isStringLiteral())
                    .map((x) => x.getLiteralValue()))
                    .reduce((prev, cur) => [...prev, ...cur], []),
            },
        ]);
    for (let dependency of dependencies) {
        const interfaces = dependency.getInterfaces().filter((x) => !!declaredServices.find((s) => s.name == x.getName()));
        for (let intf of interfaces) {
            dependenciesMap[intf.getName()] = intf;
        }
    }
    log.debug("generating program");
    const program = TJS.getProgramFromFiles(project.getSourceFiles().map((x) => x.getFilePath()));
    log.debug("generating schema");
    let schema = TJS.generateSchema(program, typeAliasName, {
        excludePrivate: true,
        propOrder: true,
        ignoreErrors: true,
        required: true,
    });
    if (typeof (schema === null || schema === void 0 ? void 0 : schema.anyOf) !== "undefined") {
        schema.oneOf = schema.anyOf;
        delete schema.anyOf;
    }
    const schemaOutputPath = path.join(config_1.default.root, config_1.default.resources.output.schemas, "objects.json");
    const schemaStubOutputPath = path.join(config_1.default.root, config_1.default.resources.output.schemas, "resources.json");
    if (!fs.existsSync(path.dirname(schemaOutputPath))) {
        log.debug("creating directory", path.dirname(schemaOutputPath));
        fs.mkdirSync(path.dirname(schemaOutputPath), { recursive: true });
    }
    const contributorsMeta = ((_c = config_1.default.resources.contributors) !== null && _c !== void 0 ? _c : []).map((x) => {
        try {
            const modulePath = path.join(path.dirname(fs.existsSync(path.join(config_1.default.root, x))
                ? path.join(config_1.default.root, x, ".kubernate/resources.meta")
                : require.resolve(x + "/.kubernate/resources.meta", { paths: [config_1.default.root] })), "../");
            if (!fs.existsSync(modulePath)) {
                log.fatal("could not load contributor", x);
                process.exit(1);
            }
            const metaPath = path.join(modulePath, ".kubernate", "resources.meta");
            if (!fs.existsSync(metaPath)) {
                log.fatal(x, "is not a valid contributor!", metaPath, "is missing");
                process.exit(1);
            }
            return {
                meta: JSON.parse(fs.readFileSync(metaPath, "utf8")),
                root: path.dirname(modulePath),
                filePath: metaPath,
                relativeToRoot: path.relative(path.dirname(schemaOutputPath), modulePath),
            };
        }
        catch (ex) {
            log.fatal("could not load contributor", x);
            process.exit(1);
        }
    });
    log.info("writing schema to", schemaStubOutputPath);
    fs.writeFileSync(schemaOutputPath, JSON.stringify(schema, null, 4));
    fs.writeFileSync(schemaStubOutputPath, JSON.stringify({
        $schema: "http://json-schema.org/draft-07/schema#",
        oneOf: [
            {
                $ref: "objects.json",
            },
            ...contributorsMeta.map((x) => ({ $ref: path.join(x.relativeToRoot, x.meta.absoluteOutputs.schemas.main) })),
        ],
    }, null, 4));
    const outputSourceFile = project.createSourceFile(path.join(config_1.default.root, config_1.default.resources.output.code, "declarations.ts"), "", {
        overwrite: true,
    });
    for (let serviceSpec of declaredServices) {
        const serviceInterface = dependenciesMap[serviceSpec.name];
        outputSourceFile.addImportDeclaration({
            moduleSpecifier: outputSourceFile.getRelativePathAsModuleSpecifierTo(serviceInterface.getSourceFile().getFilePath()),
            namedImports: [serviceSpec.name],
        });
    }
    if (!fs.existsSync(path.dirname(outputSourceFile.getFilePath()))) {
        log.debug("creating directory", path.dirname(outputSourceFile.getFilePath()));
        fs.mkdirSync(path.dirname(outputSourceFile.getFilePath()), { recursive: true });
    }
    fs.writeFileSync(outputSourceFile.getFilePath(), `
/**
* This file was generated by kubernate.
* Do not edit this file manually. Any changes will be overwritten.
*/
${outputSourceFile.getText()}

export type DeclaredServicesMap = {
${declaredServices.map((x) => `\t"${x.typeArgs.join("/")}": ${x.name}`).join(",\n")}
};
`);
    fs.writeFileSync(path.join(config_1.default.root, config_1.default.resources.output.code, "index.ts"), `
/**
* This file was generated by kubernate.
* Do not edit this file manually. Any changes will be overwritten.
*/
import {makeResourcesBrowser} from "kubernate/internal/api";
import {join as pathJoin} from "path";
import {DeclaredServicesMap} from "./declarations";

const resources = makeResourcesBrowser<DeclaredServicesMap>(pathJoin(__dirname, "${path.relative(path.dirname(path.join(config_1.default.root, config_1.default.resources.output.code, "index.ts")), config_1.default.root)}"));
export default resources;
`);
    const metadataOutputPath = path.join(config_1.default.root, ".kubernate", "resources.meta");
    if (!fs.existsSync(path.dirname(metadataOutputPath))) {
        log.debug("creating directory", path.dirname(metadataOutputPath));
        fs.mkdirSync(path.dirname(metadataOutputPath), { recursive: true });
    }
    fs.writeFileSync(metadataOutputPath, JSON.stringify({
        ...config_1.default.resources,
        absoluteOutputs: {
            code: outputSourceFile.getFilePath().replace(config_1.default.root, "."),
            schemas: {
                main: schemaStubOutputPath.replace(config_1.default.root, "."),
                objects: schemaOutputPath.replace(config_1.default.root, "."),
            },
        },
    }, null, 4));
}
//# sourceMappingURL=generate.js.map